:original_name: opengauss_opti_0051.html

.. _opengauss_opti_0051:

Experience in Rewriting SQL Statements
======================================

Based on the SQL execution mechanism and a large number of practices, SQL statements can be optimized by following certain rules to enable the database to execute SQL statements more quickly and obtain correct results. You can comply with these rules to improve service query efficiency.

-  Replacing **UNION** with **UNION ALL**

   **UNION** eliminates duplicate rows while merging two result sets. **UNION ALL** merges the two result sets without deduplication. Therefore, replace **UNION** with **UNION ALL** if you are sure that the two result sets do not contain duplicate rows based on the service logic.

-  **Adding NOT NULL to the join column**

   If there are many **NULL** values in the **JOIN** columns, you can add the filter criterion **IS NOT NULL** to filter data in advance to improve the **JOIN** efficiency.

-  **Converting NOT IN to NOT EXISTS**

   **nestloop anti join** must be used to implement **NOT IN**, and **hash anti join** is required for **NOT EXISTS**. If no **NULL** value exists in the **JOIN** columns, **NOT IN** is equivalent to **NOT EXISTS**. Therefore, if you are sure that no **NULL** value exists, you can convert **NOT IN** to **NOT EXISTS** to generate **hash join** and to improve the query performance.

   As shown in the following figure, the **t2.d2** column does not contain null values (it is set to **NOT NULL**) and **NOT EXISTS** is used for the query.

   SELECT \* FROM t1 WHERE NOT EXISTS (SELECT \* FROM t2 WHERE t1.c1=t2.d2);

   The generated execution plan is as follows:


   .. figure:: /_static/images/en-us_image_0000002088678122.png
      :alt: **Figure 1** NOT EXISTS execution plan

      **Figure 1** NOT EXISTS execution plan

-  Using **hashagg**

   If a plan involving **groupAgg** and **SORT** operations generated by the **GROUP BY** statement is poor in performance, you can set **work_mem** to a larger value to generate a **hashagg** plan, which does not require sorting and improves the performance.

-  **Replacing functions with** **CASE** **statements**

   The GaussDB performance greatly deteriorates if a large number of functions are called. In this case, you can modify the pushdown functions to **CASE** statements.

-  **Avoid using functions or expressions for indexes.**

   Using functions or expressions for indexes stops indexing. Instead, it enables scanning on the full table.

-  **Avoid using** **!=** **or** **<>** **operators,** **NULL,** **OR, or implicit parameter conversion in** **WHERE** **clauses.**

-  **Splitting complex SQL statements**

   You can split an SQL statement into several ones and save the execution result to a temporary table if the SQL statement is too complex to be tuned using the solutions above, including but not limited to the following scenarios:

   -  The same subquery is involved in multiple SQL statements of a job and the subquery contains a large amount of data.
   -  Incorrect **Plan cost** causes a small hash bucket of subquery. For example, the actual number of rows is 10 million, but only 1,000 rows are in hash bucket.
   -  Functions such as **substr** and **to_number** cause incorrect measures for subqueries containing a large amount of data.
   -  **BROADCAST** subqueries are performed on large tables in multi-DN environment.
